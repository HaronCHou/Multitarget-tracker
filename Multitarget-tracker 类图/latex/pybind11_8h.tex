\hypertarget{pybind11_8h}{}\doxysection{D\+:/zhr\+\_\+files/\+Multitarget-\/tracker-\/master/thirdparty/pybind11/include/pybind11/pybind11.h 文件参考}
\label{pybind11_8h}\index{D:/zhr\_files/Multitarget-\/tracker-\/master/thirdparty/pybind11/include/pybind11/pybind11.h@{D:/zhr\_files/Multitarget-\/tracker-\/master/thirdparty/pybind11/include/pybind11/pybind11.h}}
{\ttfamily \#include \char`\"{}attr.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}options.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}detail/class.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}detail/init.\+h\char`\"{}}\newline
pybind11.\+h 的引用(Include)关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h__incl}
\end{center}
\end{figure}
此图展示该文件直接或间接的被哪些文件引用了\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classcpp__function}{cpp\+\_\+function}}
\begin{DoxyCompactList}\small\item\em Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classmodule}{module}}
\begin{DoxyCompactList}\small\item\em Wrapper for Python extension modules \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgeneric__type}{generic\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Generic support for creating new Python heap types \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhas__operator__delete}{has\+\_\+operator\+\_\+delete$<$ T, SFINAE $>$}}
\item 
struct \mbox{\hyperlink{structhas__operator__delete_3_01_t_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_08_07vbad95f4ce94079b9ba36252dd72d93b5}{has\+\_\+operator\+\_\+delete$<$ T, void\+\_\+t$<$ decltype(static\+\_\+cast$<$ void($\ast$)(void $\ast$)$>$(\+T\+::operator delete))$>$ $>$}}
\item 
struct \mbox{\hyperlink{structhas__operator__delete__size}{has\+\_\+operator\+\_\+delete\+\_\+size$<$ T, SFINAE $>$}}
\item 
struct \mbox{\hyperlink{structhas__operator__delete__size_3_01_t_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_e659cd67a562b6670920a523a8edb40c}{has\+\_\+operator\+\_\+delete\+\_\+size$<$ T, void\+\_\+t$<$ decltype(static\+\_\+cast$<$ void($\ast$)(void $\ast$, size\+\_\+t)$>$(\+T\+::operator delete))$>$ $>$}}
\item 
class \mbox{\hyperlink{classclass__}{class\+\_\+$<$ type\+\_\+, options $>$}}
\item 
struct \mbox{\hyperlink{structclass___1_1is__valid__class__option}{class\+\_\+$<$ type\+\_\+, options $>$\+::is\+\_\+valid\+\_\+class\+\_\+option$<$ T $>$}}
\item 
struct \mbox{\hyperlink{structenum__base}{enum\+\_\+base}}
\item 
class \mbox{\hyperlink{classenum__}{enum\+\_\+$<$ Type $>$}}
\begin{DoxyCompactList}\small\item\em Binds C++ enumerations and enumeration classes to Python \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structiterator__state}{iterator\+\_\+state$<$ Iterator, Sentinel, Key\+Iterator, Policy $>$}}
\item 
class \mbox{\hyperlink{classexception}{exception$<$ type $>$}}
\item 
class \mbox{\hyperlink{classgil__scoped__acquire}{gil\+\_\+scoped\+\_\+acquire}}
\item 
class \mbox{\hyperlink{classgil__scoped__release}{gil\+\_\+scoped\+\_\+release}}
\end{DoxyCompactItemize}
\doxysubsection*{宏定义}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{pybind11_8h_adade02474502609b96c61b2054218bcf}{PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+STRICT}}(op,  expr,  strict\+\_\+behavior)
\item 
\#define \mbox{\hyperlink{pybind11_8h_a91fd1ef72c39ba18ce5223e17d8a1caa}{PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+CONV}}(op,  expr)
\item 
\#define \mbox{\hyperlink{pybind11_8h_a1af9d4d51bae345dfc06b6c6fcfd9fdb}{PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+CONV\+\_\+\+LHS}}(op,  expr)
\item 
\#define \mbox{\hyperlink{pybind11_8h_acc16e5b178730313f1372d6e1be4e414}{PYBIND11\+\_\+\+THROW}}~throw type\+\_\+error(\char`\"{}Expected an enumeration of matching type!\char`\"{});
\item 
\#define \mbox{\hyperlink{pybind11_8h_ad225e789a43a99757532d624f794b377}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+INT}}(ret\+\_\+type,  cname,  \mbox{\hyperlink{structname}{name}}, ...)
\item 
\#define \mbox{\hyperlink{pybind11_8h_a6a5ebc119f4e7ca7ccb05d9d1f64d547}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME}}(ret\+\_\+type,  cname,  \mbox{\hyperlink{structname}{name}},  fn, ...)
\item 
\#define \mbox{\hyperlink{pybind11_8h_a52b952e976930f2149eec9d0eb450100}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE\+\_\+\+NAME}}(ret\+\_\+type,  cname,  \mbox{\hyperlink{structname}{name}},  fn, ...)
\item 
\#define \mbox{\hyperlink{pybind11_8h_a554e6c4e025a0a1a1d8b30998144e386}{PYBIND11\+\_\+\+OVERLOAD}}(ret\+\_\+type,  cname,  fn, ...)~    \mbox{\hyperlink{pybind11_8h_a6a5ebc119f4e7ca7ccb05d9d1f64d547}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(ret\+\_\+type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(cname), \#fn, fn, \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+)
\item 
\#define \mbox{\hyperlink{pybind11_8h_acf72084f40e31c334fd2d2b0161e959b}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE}}(ret\+\_\+type,  cname,  fn, ...)~    \mbox{\hyperlink{pybind11_8h_a52b952e976930f2149eec9d0eb450100}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE\+\_\+\+NAME}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(ret\+\_\+type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(cname), \#fn, fn, \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+)
\end{DoxyCompactItemize}
\doxysubsection*{函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classdict}{dict}} \mbox{\hyperlink{group__python__builtins_ga0be04c9e8c8a6833cabae628e2243b6c}{globals}} ()
\item 
{\footnotesize template$<$typename T , typename  = void\+\_\+t$<$decltype(static\+\_\+cast$<$void $\ast$($\ast$)(size\+\_\+t)$>$(\+T\+::operator new))$>$$>$ }\\void \mbox{\hyperlink{pybind11_8h_ae55b858834fdd3c6adb5e8b9615b49b6}{set\+\_\+operator\+\_\+new}} (\mbox{\hyperlink{structtype__record}{type\+\_\+record}} $\ast$r)
\begin{DoxyCompactList}\small\item\em Set the pointer to operator new if it exists. The cast is needed because it can be overloaded. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename $>$ }\\void \mbox{\hyperlink{pybind11_8h_a32d62802b102a8ac8362eeef769aaad4}{set\+\_\+operator\+\_\+new}} (...)
\item 
{\footnotesize template$<$typename T , \mbox{\hyperlink{detail_2common_8h_a012819c9e8b5e04872a271f50f8b8196}{enable\+\_\+if\+\_\+t}}$<$ \mbox{\hyperlink{structhas__operator__delete}{has\+\_\+operator\+\_\+delete}}$<$ T $>$\+::value, int $>$  = 0$>$ }\\void \mbox{\hyperlink{pybind11_8h_a4f9edb48e1b7e9f3cf1dfa835cc39be2}{call\+\_\+operator\+\_\+delete}} (T $\ast$p, \mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}, \mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}})
\begin{DoxyCompactList}\small\item\em Call class-\/specific delete if it exists or global otherwise. Can also be an overload set. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{pybind11_8h_a5e61d624540777bbf68662f0c0da0bbf}{call\+\_\+operator\+\_\+delete}} (void $\ast$p, \mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}} s, \mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}} a)
\item 
{\footnotesize template$<$typename , typename F $>$ }\\auto \mbox{\hyperlink{pybind11_8h_a133120592be1caf7036580978b5bd6dd}{method\+\_\+adaptor}} (F \&\&\mbox{\hyperlink{rings_8cpp_a77369fc4d5326a16d2c603e032023528}{f}}) -\/$>$ decltype(std\+::forward$<$ F $>$(\mbox{\hyperlink{rings_8cpp_a77369fc4d5326a16d2c603e032023528}{f}}))
\item 
{\footnotesize template$<$typename Derived , typename Return , typename Class , typename... Args$>$ }\\auto \mbox{\hyperlink{pybind11_8h_adb45bb8178cd55c41b0f0d84bde00cfe}{method\+\_\+adaptor}} (Return(Class\+::$\ast$pmf)(Args...)) -\/$>$ Return(Derived\+::$\ast$)(Args...)
\item 
{\footnotesize template$<$typename... Args$>$ }\\detail\+::initimpl\+::constructor$<$ Args... $>$ \mbox{\hyperlink{pybind11_8h_ac4274fb6697bc2dee6b5e3d1170525c0}{init}} ()
\begin{DoxyCompactList}\small\item\em Binds an existing constructor taking arguments Args... \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\detail\+::initimpl\+::alias\+\_\+constructor$<$ Args... $>$ \mbox{\hyperlink{pybind11_8h_a40c2c8e69bf2708e60893e060b172d3a}{init\+\_\+alias}} ()
\item 
{\footnotesize template$<$typename Func , typename Ret  = detail\+::initimpl\+::factory$<$\+Func$>$$>$ }\\Ret \mbox{\hyperlink{pybind11_8h_a1ca0a3cdc2264eb2b0d36acd762c8bae}{init}} (Func \&\&\mbox{\hyperlink{rings_8cpp_a77369fc4d5326a16d2c603e032023528}{f}})
\begin{DoxyCompactList}\small\item\em Binds a factory function as a constructor \end{DoxyCompactList}\item 
{\footnotesize template$<$typename CFunc , typename AFunc , typename Ret  = detail\+::initimpl\+::factory$<$\+CFunc, AFunc$>$$>$ }\\Ret \mbox{\hyperlink{pybind11_8h_a144961765ca31801e21d87651871934c}{init}} (CFunc \&\&c, AFunc \&\&a)
\item 
{\footnotesize template$<$typename Get\+State , typename Set\+State $>$ }\\detail\+::initimpl\+::pickle\+\_\+factory$<$ Get\+State, Set\+State $>$ \mbox{\hyperlink{pybind11_8h_ac6c6b96e22a5ef72511d5aac6988c8e5}{pickle}} (Get\+State \&\&\mbox{\hyperlink{rings_8cpp_aa9df5aa3976a89a96a5f1c7611d42938}{g}}, Set\+State \&\&s)
\item 
void \mbox{\hyperlink{pybind11_8h_a8930f52c7348c6cf3c2c9195abbb3964}{keep\+\_\+alive\+\_\+impl}} (\mbox{\hyperlink{classhandle}{handle}} nurse, \mbox{\hyperlink{classhandle}{handle}} patient)
\item 
\mbox{\hyperlink{detail_2common_8h_a1fb186b7494d5c576d902c0730ecbb71}{PYBIND11\+\_\+\+NOINLINE}} void \mbox{\hyperlink{pybind11_8h_aa1bda75120c8e859c75dfd2f5a266c7b}{keep\+\_\+alive\+\_\+impl}} (\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}} Nurse, \mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}} Patient, \mbox{\hyperlink{structfunction__call}{function\+\_\+call}} \&call, \mbox{\hyperlink{classhandle}{handle}} ret)
\item 
std\+::pair$<$ decltype(\mbox{\hyperlink{structinternals_a6148bb4956e17d8a61f410cac7227d04}{internals\+::registered\+\_\+types\+\_\+py}})\mbox{\hyperlink{classiterator}{\+::iterator}}, bool $>$ \mbox{\hyperlink{pybind11_8h_aef025a4af8a46127594ecb41de1094e4}{all\+\_\+type\+\_\+info\+\_\+get\+\_\+cache}} (Py\+Type\+Object $\ast$type)
\item 
{\footnotesize template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Iterator , typename Sentinel , typename Value\+Type  = decltype($\ast$std\+::declval$<$\+Iterator$>$()), typename... Extra$>$ }\\\mbox{\hyperlink{classiterator}{iterator}} \mbox{\hyperlink{pybind11_8h_aaa00ecd4f616ff84b63e81c8e17e457d}{make\+\_\+iterator}} (Iterator \mbox{\hyperlink{detail_2common_8h_a4cf51fa5731f737b40acc39bae3ed154}{first}}, Sentinel \mbox{\hyperlink{detail_2common_8h_a98cc70241f124ef088fa2d7d716166fd}{last}}, Extra \&\&... extra)
\begin{DoxyCompactList}\small\item\em Makes a python iterator from a first and past-\/the-\/end C++ Input\+Iterator. \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Iterator , typename Sentinel , typename Key\+Type  = decltype(($\ast$std\+::declval$<$\+Iterator$>$()).\+first), typename... Extra$>$ }\\\mbox{\hyperlink{classiterator}{iterator}} \mbox{\hyperlink{pybind11_8h_a53d442f04a8921c7dcc4407b05420752}{make\+\_\+key\+\_\+iterator}} (Iterator \mbox{\hyperlink{detail_2common_8h_a4cf51fa5731f737b40acc39bae3ed154}{first}}, Sentinel \mbox{\hyperlink{detail_2common_8h_a98cc70241f124ef088fa2d7d716166fd}{last}}, Extra \&\&... extra)
\item 
{\footnotesize template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Type , typename... Extra$>$ }\\\mbox{\hyperlink{classiterator}{iterator}} \mbox{\hyperlink{pybind11_8h_af2f2f5b99f97863427786e74223e4b0a}{make\+\_\+iterator}} (Type \&value, Extra \&\&... extra)
\item 
{\footnotesize template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Type , typename... Extra$>$ }\\\mbox{\hyperlink{classiterator}{iterator}} \mbox{\hyperlink{pybind11_8h_ae01589476d0346c3e936852e4c27a62b}{make\+\_\+key\+\_\+iterator}} (Type \&value, Extra \&\&... extra)
\item 
{\footnotesize template$<$typename Input\+Type , typename Output\+Type $>$ }\\void \mbox{\hyperlink{pybind11_8h_a271a0a8cc9839658c668492cbaa1035a}{implicitly\+\_\+convertible}} ()
\item 
{\footnotesize template$<$typename Exception\+Translator $>$ }\\void \mbox{\hyperlink{pybind11_8h_a0a77063d21919c13ddfeb8caf29eef59}{register\+\_\+exception\+\_\+translator}} (Exception\+Translator \&\&translator)
\item 
{\footnotesize template$<$typename Cpp\+Exception $>$ }\\\mbox{\hyperlink{classexception}{exception}}$<$ Cpp\+Exception $>$ \& \mbox{\hyperlink{pybind11_8h_a2a418b49924ecc774541489d6e74f3d4}{get\+\_\+exception\+\_\+object}} ()
\item 
{\footnotesize template$<$typename Cpp\+Exception $>$ }\\\mbox{\hyperlink{classexception}{exception}}$<$ Cpp\+Exception $>$ \& \mbox{\hyperlink{pybind11_8h_a5ed31cd3b863c5a47ffc88f6babef69e}{register\+\_\+exception}} (\mbox{\hyperlink{classhandle}{handle}} \mbox{\hyperlink{structscope}{scope}}, const char $\ast$\mbox{\hyperlink{structname}{name}}, Py\+Object $\ast$\mbox{\hyperlink{structbase}{base}}=Py\+Exc\+\_\+\+Exception)
\item 
\mbox{\hyperlink{detail_2common_8h_a1fb186b7494d5c576d902c0730ecbb71}{PYBIND11\+\_\+\+NOINLINE}} void \mbox{\hyperlink{pybind11_8h_a62bcafa97abdcadb6520a62e52331b89}{print}} (\mbox{\hyperlink{classtuple}{tuple}} \mbox{\hyperlink{classargs}{args}}, \mbox{\hyperlink{classdict}{dict}} \mbox{\hyperlink{classkwargs}{kwargs}})
\item 
{\footnotesize template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} policy = return\+\_\+value\+\_\+policy\+::automatic\+\_\+reference, typename... Args$>$ }\\void \mbox{\hyperlink{pybind11_8h_a09d68b02745a7821c256c0642fb096c9}{print}} (Args \&\&...\mbox{\hyperlink{classargs}{args}})
\item 
\mbox{\hyperlink{classfunction}{function}} \mbox{\hyperlink{pybind11_8h_a9e918cccfeeabbbe9b1a42bba6b30a42}{get\+\_\+type\+\_\+overload}} (const void $\ast$this\+\_\+ptr, const detail\+::type\+\_\+info $\ast$this\+\_\+type, const char $\ast$\mbox{\hyperlink{structname}{name}})
\item 
{\footnotesize template$<$class T $>$ }\\\mbox{\hyperlink{classfunction}{function}} \mbox{\hyperlink{pybind11_8h_a6e5733211206597cdff171d9d43d8332}{get\+\_\+overload}} (const T $\ast$this\+\_\+ptr, const char $\ast$\mbox{\hyperlink{structname}{name}})
\end{DoxyCompactItemize}


\doxysubsection{宏定义说明}
\mbox{\Hypertarget{pybind11_8h_a91fd1ef72c39ba18ce5223e17d8a1caa}\label{pybind11_8h_a91fd1ef72c39ba18ce5223e17d8a1caa}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_ENUM\_OP\_CONV@{PYBIND11\_ENUM\_OP\_CONV}}
\index{PYBIND11\_ENUM\_OP\_CONV@{PYBIND11\_ENUM\_OP\_CONV}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_ENUM\_OP\_CONV}{PYBIND11\_ENUM\_OP\_CONV}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+CONV(\begin{DoxyParamCaption}\item[{}]{op,  }\item[{}]{expr }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{            m\_base.attr(op) = \mbox{\hyperlink{classcpp__function}{cpp\_function}}(                                            \(\backslash\)}
\DoxyCodeLine{                [](\textcolor{keywordtype}{object} a\_, \textcolor{keywordtype}{object} b\_) \{                                             \(\backslash\)}
\DoxyCodeLine{                    int\_ a(a\_), b(b\_);                                                 \(\backslash\)}
\DoxyCodeLine{                    return expr;                                                       \(\backslash\)}
\DoxyCodeLine{                \},                                                                     \(\backslash\)}
\DoxyCodeLine{                is\_method(m\_base))}

\end{DoxyCode}
\mbox{\Hypertarget{pybind11_8h_a1af9d4d51bae345dfc06b6c6fcfd9fdb}\label{pybind11_8h_a1af9d4d51bae345dfc06b6c6fcfd9fdb}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_ENUM\_OP\_CONV\_LHS@{PYBIND11\_ENUM\_OP\_CONV\_LHS}}
\index{PYBIND11\_ENUM\_OP\_CONV\_LHS@{PYBIND11\_ENUM\_OP\_CONV\_LHS}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_ENUM\_OP\_CONV\_LHS}{PYBIND11\_ENUM\_OP\_CONV\_LHS}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+CONV\+\_\+\+LHS(\begin{DoxyParamCaption}\item[{}]{op,  }\item[{}]{expr }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{            m\_base.attr(op) = \mbox{\hyperlink{classcpp__function}{cpp\_function}}(                                            \(\backslash\)}
\DoxyCodeLine{                [](\textcolor{keywordtype}{object} a\_, \textcolor{keywordtype}{object} b) \{                                              \(\backslash\)}
\DoxyCodeLine{                    int\_ a(a\_);                                                        \(\backslash\)}
\DoxyCodeLine{                    return expr;                                                       \(\backslash\)}
\DoxyCodeLine{                \},                                                                     \(\backslash\)}
\DoxyCodeLine{                is\_method(m\_base))}

\end{DoxyCode}
\mbox{\Hypertarget{pybind11_8h_adade02474502609b96c61b2054218bcf}\label{pybind11_8h_adade02474502609b96c61b2054218bcf}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_ENUM\_OP\_STRICT@{PYBIND11\_ENUM\_OP\_STRICT}}
\index{PYBIND11\_ENUM\_OP\_STRICT@{PYBIND11\_ENUM\_OP\_STRICT}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_ENUM\_OP\_STRICT}{PYBIND11\_ENUM\_OP\_STRICT}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+ENUM\+\_\+\+OP\+\_\+\+STRICT(\begin{DoxyParamCaption}\item[{}]{op,  }\item[{}]{expr,  }\item[{}]{strict\+\_\+behavior }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{            m\_base.attr(op) = \mbox{\hyperlink{classcpp__function}{cpp\_function}}(                                            \(\backslash\)}
\DoxyCodeLine{                [](\textcolor{keywordtype}{object} a, \textcolor{keywordtype}{object} b) \{                                               \(\backslash\)}
\DoxyCodeLine{                    if (!a.get\_type().is(b.get\_type()))                                \(\backslash\)}
\DoxyCodeLine{                        strict\_behavior;                                               \(\backslash\)}
\DoxyCodeLine{                    return expr;                                                       \(\backslash\)}
\DoxyCodeLine{                \},                                                                     \(\backslash\)}
\DoxyCodeLine{                is\_method(m\_base))}

\end{DoxyCode}
\mbox{\Hypertarget{pybind11_8h_a554e6c4e025a0a1a1d8b30998144e386}\label{pybind11_8h_a554e6c4e025a0a1a1d8b30998144e386}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_OVERLOAD@{PYBIND11\_OVERLOAD}}
\index{PYBIND11\_OVERLOAD@{PYBIND11\_OVERLOAD}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_OVERLOAD}{PYBIND11\_OVERLOAD}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+OVERLOAD(\begin{DoxyParamCaption}\item[{}]{ret\+\_\+type,  }\item[{}]{cname,  }\item[{}]{fn,  }\item[{}]{... }\end{DoxyParamCaption})~    \mbox{\hyperlink{pybind11_8h_a6a5ebc119f4e7ca7ccb05d9d1f64d547}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(ret\+\_\+type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(cname), \#fn, fn, \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+)}

\textbackslash{}rst Macro to populate the virtual method in the trampoline class. This macro tries to look up the method from the Python side, deals with the \+:ref\+:{\ttfamily gil} and necessary argument conversions to call this method and return the appropriate type. This macro should be used if the method name in C and in Python are identical. See \+:ref\+:{\ttfamily overriding\+\_\+virtuals} for more information.

.. code-\/block\+:: cpp

class Py\+Animal \+: public Animal \{ public\+: Inherit the constructors using Animal\+::\+Animal;

Trampoline (need one for each virtual function) std\+::string go(int n\+\_\+times) override \{ PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE( std\+::string, // Return type (ret\+\_\+type) Animal, // Parent class (cname) go, // Name of function in C++ (must match Python name) (fn) n\+\_\+times // Argument(s) (...) ); \} \}; \textbackslash{}endrst \mbox{\Hypertarget{pybind11_8h_ad225e789a43a99757532d624f794b377}\label{pybind11_8h_ad225e789a43a99757532d624f794b377}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_OVERLOAD\_INT@{PYBIND11\_OVERLOAD\_INT}}
\index{PYBIND11\_OVERLOAD\_INT@{PYBIND11\_OVERLOAD\_INT}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_OVERLOAD\_INT}{PYBIND11\_OVERLOAD\_INT}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+OVERLOAD\+\_\+\+INT(\begin{DoxyParamCaption}\item[{}]{ret\+\_\+type,  }\item[{}]{cname,  }\item[{}]{\mbox{\hyperlink{structname}{name}},  }\item[{}]{... }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \{ \(\backslash\)}
\DoxyCodeLine{        pybind11::gil\_scoped\_acquire gil; \(\backslash\)}
\DoxyCodeLine{        pybind11::function overload = \mbox{\hyperlink{pybind11_8h_a6e5733211206597cdff171d9d43d8332}{pybind11::get\_overload}}(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }cname *\textcolor{keyword}{>}(\textcolor{keyword}{this}), \mbox{\hyperlink{structname}{name}}); \(\backslash\)}
\DoxyCodeLine{        if (overload) \{ \(\backslash\)}
\DoxyCodeLine{            auto o = overload(\_\_VA\_ARGS\_\_); \(\backslash\)}
\DoxyCodeLine{            if (pybind11::detail::cast\_is\_temporary\_value\_reference<ret\_type>::value) \{ \(\backslash\)}
\DoxyCodeLine{                static pybind11::detail::overload\_caster\_t<ret\_type> caster; \(\backslash\)}
\DoxyCodeLine{                return pybind11::detail::cast\_ref<ret\_type>(std::move(o), caster); \(\backslash\)}
\DoxyCodeLine{            \} \(\backslash\)}
\DoxyCodeLine{            else \textcolor{keywordflow}{return} pybind11::detail::cast\_safe<ret\_type>(std::move(o)); \(\backslash\)}
\DoxyCodeLine{        \} \(\backslash\)}
\DoxyCodeLine{    \}}

\end{DoxyCode}
\mbox{\Hypertarget{pybind11_8h_a6a5ebc119f4e7ca7ccb05d9d1f64d547}\label{pybind11_8h_a6a5ebc119f4e7ca7ccb05d9d1f64d547}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_OVERLOAD\_NAME@{PYBIND11\_OVERLOAD\_NAME}}
\index{PYBIND11\_OVERLOAD\_NAME@{PYBIND11\_OVERLOAD\_NAME}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_OVERLOAD\_NAME}{PYBIND11\_OVERLOAD\_NAME}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME(\begin{DoxyParamCaption}\item[{}]{ret\+\_\+type,  }\item[{}]{cname,  }\item[{}]{\mbox{\hyperlink{structname}{name}},  }\item[{}]{fn,  }\item[{}]{... }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \mbox{\hyperlink{pybind11_8h_ad225e789a43a99757532d624f794b377}{PYBIND11\_OVERLOAD\_INT}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\_TYPE}}(ret\_type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\_TYPE}}(cname), \mbox{\hyperlink{structname}{name}}, \_\_VA\_ARGS\_\_) \(\backslash\)}
\DoxyCodeLine{    return cname::fn(\_\_VA\_ARGS\_\_)}

\end{DoxyCode}
\textbackslash{}rst Macro to populate the virtual method in the trampoline class. This macro tries to look up a method named \textquotesingle{}fn\textquotesingle{} from the Python side, deals with the \+:ref\+:{\ttfamily gil} and necessary argument conversions to call this method and return the appropriate type. See \+:ref\+:{\ttfamily overriding\+\_\+virtuals} for more information. This macro should be used when the method name in C is not the same as the method name in Python. For example with {\ttfamily \+\_\+\+\_\+str\+\_\+\+\_\+}.

.. code-\/block\+:: cpp

std\+::string to\+String() override \{ PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME( std\+::string, // Return type (ret\+\_\+type) Animal, // Parent class (cname) to\+String, // Name of function in C++ (name) \char`\"{}\+\_\+\+\_\+str\+\_\+\+\_\+\char`\"{}, // Name of method in Python (fn) ); \} \textbackslash{}endrst \mbox{\Hypertarget{pybind11_8h_acf72084f40e31c334fd2d2b0161e959b}\label{pybind11_8h_acf72084f40e31c334fd2d2b0161e959b}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_OVERLOAD\_PURE@{PYBIND11\_OVERLOAD\_PURE}}
\index{PYBIND11\_OVERLOAD\_PURE@{PYBIND11\_OVERLOAD\_PURE}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_OVERLOAD\_PURE}{PYBIND11\_OVERLOAD\_PURE}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE(\begin{DoxyParamCaption}\item[{}]{ret\+\_\+type,  }\item[{}]{cname,  }\item[{}]{fn,  }\item[{}]{... }\end{DoxyParamCaption})~    \mbox{\hyperlink{pybind11_8h_a52b952e976930f2149eec9d0eb450100}{PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE\+\_\+\+NAME}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(ret\+\_\+type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\+\_\+\+TYPE}}(cname), \#fn, fn, \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+)}

\textbackslash{}rst Macro for pure virtual functions, this function is identical to \+:c\+:macro\+:{\ttfamily PYBIND11\+\_\+\+OVERLOAD}, except that it throws if no overload can be found. \textbackslash{}endrst \mbox{\Hypertarget{pybind11_8h_a52b952e976930f2149eec9d0eb450100}\label{pybind11_8h_a52b952e976930f2149eec9d0eb450100}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_OVERLOAD\_PURE\_NAME@{PYBIND11\_OVERLOAD\_PURE\_NAME}}
\index{PYBIND11\_OVERLOAD\_PURE\_NAME@{PYBIND11\_OVERLOAD\_PURE\_NAME}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_OVERLOAD\_PURE\_NAME}{PYBIND11\_OVERLOAD\_PURE\_NAME}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+OVERLOAD\+\_\+\+PURE\+\_\+\+NAME(\begin{DoxyParamCaption}\item[{}]{ret\+\_\+type,  }\item[{}]{cname,  }\item[{}]{\mbox{\hyperlink{structname}{name}},  }\item[{}]{fn,  }\item[{}]{... }\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \mbox{\hyperlink{pybind11_8h_ad225e789a43a99757532d624f794b377}{PYBIND11\_OVERLOAD\_INT}}(\mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\_TYPE}}(ret\_type), \mbox{\hyperlink{cast_8h_abf638a034b5ed51437f70d736e85c0a6}{PYBIND11\_TYPE}}(cname), \mbox{\hyperlink{structname}{name}}, \_\_VA\_ARGS\_\_) \mbox{\hyperlink{detail_2common_8h_aeea9746c2787bab3a5a0c983ef965520}{\(\backslash\)}}}
\DoxyCodeLine{\mbox{\hyperlink{detail_2common_8h_aeea9746c2787bab3a5a0c983ef965520}{    pybind11::pybind11\_fail}}(\textcolor{stringliteral}{"{}Tried to call pure virtual function \(\backslash\)"{}"{}} \mbox{\hyperlink{detail_2common_8h_ab822e781bd1668e8bd7bd3de1b610978}{PYBIND11\_STRINGIFY}}(cname) \textcolor{stringliteral}{"{}::"{}} \mbox{\hyperlink{structname}{name}} \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}

\end{DoxyCode}
\textbackslash{}rst Macro for pure virtual functions, this function is identical to \+:c\+:macro\+:{\ttfamily PYBIND11\+\_\+\+OVERLOAD\+\_\+\+NAME}, except that it throws if no overload can be found. \textbackslash{}endrst \mbox{\Hypertarget{pybind11_8h_acc16e5b178730313f1372d6e1be4e414}\label{pybind11_8h_acc16e5b178730313f1372d6e1be4e414}} 
\index{pybind11.h@{pybind11.h}!PYBIND11\_THROW@{PYBIND11\_THROW}}
\index{PYBIND11\_THROW@{PYBIND11\_THROW}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{PYBIND11\_THROW}{PYBIND11\_THROW}}
{\footnotesize\ttfamily \#define PYBIND11\+\_\+\+THROW~throw type\+\_\+error(\char`\"{}Expected an enumeration of matching type!\char`\"{});}



\doxysubsection{函数说明}
\mbox{\Hypertarget{pybind11_8h_aef025a4af8a46127594ecb41de1094e4}\label{pybind11_8h_aef025a4af8a46127594ecb41de1094e4}} 
\index{pybind11.h@{pybind11.h}!all\_type\_info\_get\_cache@{all\_type\_info\_get\_cache}}
\index{all\_type\_info\_get\_cache@{all\_type\_info\_get\_cache}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{all\_type\_info\_get\_cache()}{all\_type\_info\_get\_cache()}}
{\footnotesize\ttfamily std\+::pair$<$ decltype(\mbox{\hyperlink{structinternals_a6148bb4956e17d8a61f410cac7227d04}{internals\+::registered\+\_\+types\+\_\+py}})\mbox{\hyperlink{classiterator}{\+::iterator}}, bool $>$ all\+\_\+type\+\_\+info\+\_\+get\+\_\+cache (\begin{DoxyParamCaption}\item[{Py\+Type\+Object $\ast$}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_aef025a4af8a46127594ecb41de1094e4_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a4f9edb48e1b7e9f3cf1dfa835cc39be2}\label{pybind11_8h_a4f9edb48e1b7e9f3cf1dfa835cc39be2}} 
\index{pybind11.h@{pybind11.h}!call\_operator\_delete@{call\_operator\_delete}}
\index{call\_operator\_delete@{call\_operator\_delete}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{call\_operator\_delete()}{call\_operator\_delete()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , \mbox{\hyperlink{detail_2common_8h_a012819c9e8b5e04872a271f50f8b8196}{enable\+\_\+if\+\_\+t}}$<$ \mbox{\hyperlink{structhas__operator__delete}{has\+\_\+operator\+\_\+delete}}$<$ T $>$\+::value, int $>$  = 0$>$ \\
void call\+\_\+operator\+\_\+delete (\begin{DoxyParamCaption}\item[{T $\ast$}]{p,  }\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{s,  }\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{ }\end{DoxyParamCaption})}



Call class-\/specific delete if it exists or global otherwise. Can also be an overload set. 

\mbox{\Hypertarget{pybind11_8h_a5e61d624540777bbf68662f0c0da0bbf}\label{pybind11_8h_a5e61d624540777bbf68662f0c0da0bbf}} 
\index{pybind11.h@{pybind11.h}!call\_operator\_delete@{call\_operator\_delete}}
\index{call\_operator\_delete@{call\_operator\_delete}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{call\_operator\_delete()}{call\_operator\_delete()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void call\+\_\+operator\+\_\+delete (\begin{DoxyParamCaption}\item[{void $\ast$}]{p,  }\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{s,  }\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{pybind11_8h_a2a418b49924ecc774541489d6e74f3d4}\label{pybind11_8h_a2a418b49924ecc774541489d6e74f3d4}} 
\index{pybind11.h@{pybind11.h}!get\_exception\_object@{get\_exception\_object}}
\index{get\_exception\_object@{get\_exception\_object}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{get\_exception\_object()}{get\_exception\_object()}}
{\footnotesize\ttfamily template$<$typename Cpp\+Exception $>$ \\
\mbox{\hyperlink{classexception}{exception}}$<$ Cpp\+Exception $>$ \& get\+\_\+exception\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{pybind11_8h_a6e5733211206597cdff171d9d43d8332}\label{pybind11_8h_a6e5733211206597cdff171d9d43d8332}} 
\index{pybind11.h@{pybind11.h}!get\_overload@{get\_overload}}
\index{get\_overload@{get\_overload}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{get\_overload()}{get\_overload()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
\mbox{\hyperlink{classfunction}{function}} get\+\_\+overload (\begin{DoxyParamCaption}\item[{const T $\ast$}]{this\+\_\+ptr,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

\textbackslash{}rst Try to retrieve a python method by the provided name from the instance pointed to by the this\+\_\+ptr.

\+:this\+\_\+ptr\+: The pointer to the object the overload should be retrieved for. This should be the first non-\/trampoline class encountered in the inheritance chain. \+:name\+: The name of the overloaded Python method to retrieve. \+:return\+: The Python method by this name from the object or an empty function wrapper. \textbackslash{}endrst 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a6e5733211206597cdff171d9d43d8332_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a9e918cccfeeabbbe9b1a42bba6b30a42}\label{pybind11_8h_a9e918cccfeeabbbe9b1a42bba6b30a42}} 
\index{pybind11.h@{pybind11.h}!get\_type\_overload@{get\_type\_overload}}
\index{get\_type\_overload@{get\_type\_overload}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{get\_type\_overload()}{get\_type\_overload()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classfunction}{function}} get\+\_\+type\+\_\+overload (\begin{DoxyParamCaption}\item[{const void $\ast$}]{this\+\_\+ptr,  }\item[{const detail\+::type\+\_\+info $\ast$}]{this\+\_\+type,  }\item[{const char $\ast$}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a9e918cccfeeabbbe9b1a42bba6b30a42_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a271a0a8cc9839658c668492cbaa1035a}\label{pybind11_8h_a271a0a8cc9839658c668492cbaa1035a}} 
\index{pybind11.h@{pybind11.h}!implicitly\_convertible@{implicitly\_convertible}}
\index{implicitly\_convertible@{implicitly\_convertible}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{implicitly\_convertible()}{implicitly\_convertible()}}
{\footnotesize\ttfamily template$<$typename Input\+Type , typename Output\+Type $>$ \\
void implicitly\+\_\+convertible (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a271a0a8cc9839658c668492cbaa1035a_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_ac4274fb6697bc2dee6b5e3d1170525c0}\label{pybind11_8h_ac4274fb6697bc2dee6b5e3d1170525c0}} 
\index{pybind11.h@{pybind11.h}!init@{init}}
\index{init@{init}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename... Args$>$ \\
detail\+::initimpl\+::constructor$<$ Args... $>$ init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Binds an existing constructor taking arguments Args... 

\mbox{\Hypertarget{pybind11_8h_a144961765ca31801e21d87651871934c}\label{pybind11_8h_a144961765ca31801e21d87651871934c}} 
\index{pybind11.h@{pybind11.h}!init@{init}}
\index{init@{init}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename CFunc , typename AFunc , typename Ret  = detail\+::initimpl\+::factory$<$\+CFunc, AFunc$>$$>$ \\
Ret init (\begin{DoxyParamCaption}\item[{CFunc \&\&}]{c,  }\item[{AFunc \&\&}]{a }\end{DoxyParamCaption})}

Dual-\/argument factory function\+: the first function is called when no alias is needed, the second when an alias is needed (i.\+e. due to python-\/side inheritance). Arguments must be identical. \mbox{\Hypertarget{pybind11_8h_a1ca0a3cdc2264eb2b0d36acd762c8bae}\label{pybind11_8h_a1ca0a3cdc2264eb2b0d36acd762c8bae}} 
\index{pybind11.h@{pybind11.h}!init@{init}}
\index{init@{init}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Func , typename Ret  = detail\+::initimpl\+::factory$<$\+Func$>$$>$ \\
Ret init (\begin{DoxyParamCaption}\item[{Func \&\&}]{f }\end{DoxyParamCaption})}



Binds a factory function as a constructor 

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=174pt]{pybind11_8h_a1ca0a3cdc2264eb2b0d36acd762c8bae_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a40c2c8e69bf2708e60893e060b172d3a}\label{pybind11_8h_a40c2c8e69bf2708e60893e060b172d3a}} 
\index{pybind11.h@{pybind11.h}!init\_alias@{init\_alias}}
\index{init\_alias@{init\_alias}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{init\_alias()}{init\_alias()}}
{\footnotesize\ttfamily template$<$typename... Args$>$ \\
detail\+::initimpl\+::alias\+\_\+constructor$<$ Args... $>$ init\+\_\+alias (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Like {\ttfamily init\texorpdfstring{$<$}{<}Args...\texorpdfstring{$>$}{>}()}, but the instance is always constructed through the alias class (even when not inheriting on the Python side). \mbox{\Hypertarget{pybind11_8h_a8930f52c7348c6cf3c2c9195abbb3964}\label{pybind11_8h_a8930f52c7348c6cf3c2c9195abbb3964}} 
\index{pybind11.h@{pybind11.h}!keep\_alive\_impl@{keep\_alive\_impl}}
\index{keep\_alive\_impl@{keep\_alive\_impl}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{keep\_alive\_impl()}{keep\_alive\_impl()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void keep\+\_\+alive\+\_\+impl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhandle}{handle}}}]{nurse,  }\item[{\mbox{\hyperlink{classhandle}{handle}}}]{patient }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a8930f52c7348c6cf3c2c9195abbb3964_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_aa1bda75120c8e859c75dfd2f5a266c7b}\label{pybind11_8h_aa1bda75120c8e859c75dfd2f5a266c7b}} 
\index{pybind11.h@{pybind11.h}!keep\_alive\_impl@{keep\_alive\_impl}}
\index{keep\_alive\_impl@{keep\_alive\_impl}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{keep\_alive\_impl()}{keep\_alive\_impl()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{detail_2common_8h_a1fb186b7494d5c576d902c0730ecbb71}{PYBIND11\+\_\+\+NOINLINE}} void keep\+\_\+alive\+\_\+impl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{Nurse,  }\item[{\mbox{\hyperlink{detail_2common_8h_a801d6a451a01953ef8cbae6feb6a3638}{size\+\_\+t}}}]{Patient,  }\item[{\mbox{\hyperlink{structfunction__call}{function\+\_\+call}} \&}]{call,  }\item[{\mbox{\hyperlink{classhandle}{handle}}}]{ret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_aa1bda75120c8e859c75dfd2f5a266c7b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_aaa00ecd4f616ff84b63e81c8e17e457d}\label{pybind11_8h_aaa00ecd4f616ff84b63e81c8e17e457d}} 
\index{pybind11.h@{pybind11.h}!make\_iterator@{make\_iterator}}
\index{make\_iterator@{make\_iterator}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{make\_iterator()}{make\_iterator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Iterator , typename Sentinel , typename Value\+Type  = decltype($\ast$std\+::declval$<$\+Iterator$>$()), typename... Extra$>$ \\
\mbox{\hyperlink{classiterator}{iterator}} make\+\_\+iterator (\begin{DoxyParamCaption}\item[{Iterator}]{first,  }\item[{Sentinel}]{last,  }\item[{Extra \&\&...}]{extra }\end{DoxyParamCaption})}



Makes a python iterator from a first and past-\/the-\/end C++ Input\+Iterator. 

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_aaa00ecd4f616ff84b63e81c8e17e457d_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_af2f2f5b99f97863427786e74223e4b0a}\label{pybind11_8h_af2f2f5b99f97863427786e74223e4b0a}} 
\index{pybind11.h@{pybind11.h}!make\_iterator@{make\_iterator}}
\index{make\_iterator@{make\_iterator}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{make\_iterator()}{make\_iterator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Type , typename... Extra$>$ \\
\mbox{\hyperlink{classiterator}{iterator}} make\+\_\+iterator (\begin{DoxyParamCaption}\item[{Type \&}]{value,  }\item[{Extra \&\&...}]{extra }\end{DoxyParamCaption})}

Makes an iterator over values of an stl container or other container supporting {\ttfamily std\+::begin()}/{\ttfamily \mbox{\hyperlink{namespacelibsize_a5957fc1e6f6b0ee7cd77e1e062369d35}{std\+::end()}}} \mbox{\Hypertarget{pybind11_8h_a53d442f04a8921c7dcc4407b05420752}\label{pybind11_8h_a53d442f04a8921c7dcc4407b05420752}} 
\index{pybind11.h@{pybind11.h}!make\_key\_iterator@{make\_key\_iterator}}
\index{make\_key\_iterator@{make\_key\_iterator}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{make\_key\_iterator()}{make\_key\_iterator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Iterator , typename Sentinel , typename Key\+Type  = decltype(($\ast$std\+::declval$<$\+Iterator$>$()).\+first), typename... Extra$>$ \\
\mbox{\hyperlink{classiterator}{iterator}} make\+\_\+key\+\_\+iterator (\begin{DoxyParamCaption}\item[{Iterator}]{first,  }\item[{Sentinel}]{last,  }\item[{Extra \&\&...}]{extra }\end{DoxyParamCaption})}

Makes an python iterator over the keys ({\ttfamily .first}) of a iterator over pairs from a first and past-\/the-\/end Input\+Iterator. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a53d442f04a8921c7dcc4407b05420752_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_ae01589476d0346c3e936852e4c27a62b}\label{pybind11_8h_ae01589476d0346c3e936852e4c27a62b}} 
\index{pybind11.h@{pybind11.h}!make\_key\_iterator@{make\_key\_iterator}}
\index{make\_key\_iterator@{make\_key\_iterator}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{make\_key\_iterator()}{make\_key\_iterator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} Policy = return\+\_\+value\+\_\+policy\+::reference\+\_\+internal, typename Type , typename... Extra$>$ \\
\mbox{\hyperlink{classiterator}{iterator}} make\+\_\+key\+\_\+iterator (\begin{DoxyParamCaption}\item[{Type \&}]{value,  }\item[{Extra \&\&...}]{extra }\end{DoxyParamCaption})}

Makes an iterator over the keys ({\ttfamily .first}) of a stl map-\/like container supporting {\ttfamily std\+::begin()}/{\ttfamily \mbox{\hyperlink{namespacelibsize_a5957fc1e6f6b0ee7cd77e1e062369d35}{std\+::end()}}} \mbox{\Hypertarget{pybind11_8h_a133120592be1caf7036580978b5bd6dd}\label{pybind11_8h_a133120592be1caf7036580978b5bd6dd}} 
\index{pybind11.h@{pybind11.h}!method\_adaptor@{method\_adaptor}}
\index{method\_adaptor@{method\_adaptor}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{method\_adaptor()}{method\_adaptor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename , typename F $>$ \\
auto method\+\_\+adaptor (\begin{DoxyParamCaption}\item[{F \&\&}]{f }\end{DoxyParamCaption}) -\/$>$ decltype(std\+::forward$<$F$>$(\mbox{\hyperlink{rings_8cpp_a77369fc4d5326a16d2c603e032023528}{f}})) }

Given a pointer to a member function, cast it to its {\ttfamily Derived} version. Forward everything else unchanged. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=231pt]{pybind11_8h_a133120592be1caf7036580978b5bd6dd_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_adb45bb8178cd55c41b0f0d84bde00cfe}\label{pybind11_8h_adb45bb8178cd55c41b0f0d84bde00cfe}} 
\index{pybind11.h@{pybind11.h}!method\_adaptor@{method\_adaptor}}
\index{method\_adaptor@{method\_adaptor}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{method\_adaptor()}{method\_adaptor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived , typename Return , typename Class , typename... Args$>$ \\
auto method\+\_\+adaptor (\begin{DoxyParamCaption}\item[{Return(Class\+::$\ast$)(Args...)}]{pmf }\end{DoxyParamCaption}) -\/$>$ Return (Derived\+::$\ast$)(Args...) }

\mbox{\Hypertarget{pybind11_8h_ac6c6b96e22a5ef72511d5aac6988c8e5}\label{pybind11_8h_ac6c6b96e22a5ef72511d5aac6988c8e5}} 
\index{pybind11.h@{pybind11.h}!pickle@{pickle}}
\index{pickle@{pickle}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{pickle()}{pickle()}}
{\footnotesize\ttfamily template$<$typename Get\+State , typename Set\+State $>$ \\
detail\+::initimpl\+::pickle\+\_\+factory$<$ Get\+State, Set\+State $>$ pickle (\begin{DoxyParamCaption}\item[{Get\+State \&\&}]{g,  }\item[{Set\+State \&\&}]{s }\end{DoxyParamCaption})}

Binds pickling functions {\ttfamily \+\_\+\+\_\+getstate\+\_\+\+\_\+} and {\ttfamily \+\_\+\+\_\+setstate\+\_\+\+\_\+} and ensures that the type returned by {\ttfamily \+\_\+\+\_\+getstate\+\_\+\+\_\+} is the same as the argument accepted by {\ttfamily \+\_\+\+\_\+setstate\+\_\+\+\_\+}. \mbox{\Hypertarget{pybind11_8h_a09d68b02745a7821c256c0642fb096c9}\label{pybind11_8h_a09d68b02745a7821c256c0642fb096c9}} 
\index{pybind11.h@{pybind11.h}!print@{print}}
\index{print@{print}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{print()}{print()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{detail_2common_8h_adde72ab1fb0dd4b48a5232c349a53841}{return\+\_\+value\+\_\+policy}} policy = return\+\_\+value\+\_\+policy\+::automatic\+\_\+reference, typename... Args$>$ \\
void print (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a09d68b02745a7821c256c0642fb096c9_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a62bcafa97abdcadb6520a62e52331b89}\label{pybind11_8h_a62bcafa97abdcadb6520a62e52331b89}} 
\index{pybind11.h@{pybind11.h}!print@{print}}
\index{print@{print}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{print()}{print()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{detail_2common_8h_a1fb186b7494d5c576d902c0730ecbb71}{PYBIND11\+\_\+\+NOINLINE}} void print (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtuple}{tuple}}}]{args,  }\item[{\mbox{\hyperlink{classdict}{dict}}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{pybind11_8h_a62bcafa97abdcadb6520a62e52331b89_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a5ed31cd3b863c5a47ffc88f6babef69e}\label{pybind11_8h_a5ed31cd3b863c5a47ffc88f6babef69e}} 
\index{pybind11.h@{pybind11.h}!register\_exception@{register\_exception}}
\index{register\_exception@{register\_exception}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{register\_exception()}{register\_exception()}}
{\footnotesize\ttfamily template$<$typename Cpp\+Exception $>$ \\
\mbox{\hyperlink{classexception}{exception}}$<$ Cpp\+Exception $>$ \& register\+\_\+exception (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhandle}{handle}}}]{scope,  }\item[{const char $\ast$}]{name,  }\item[{Py\+Object $\ast$}]{base = {\ttfamily PyExc\+\_\+Exception} }\end{DoxyParamCaption})}

Registers a Python exception in {\ttfamily m} of the given {\ttfamily name} and installs an exception translator to translate the C++ exception to the created Python exception using the exceptions what() method. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a5ed31cd3b863c5a47ffc88f6babef69e_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a0a77063d21919c13ddfeb8caf29eef59}\label{pybind11_8h_a0a77063d21919c13ddfeb8caf29eef59}} 
\index{pybind11.h@{pybind11.h}!register\_exception\_translator@{register\_exception\_translator}}
\index{register\_exception\_translator@{register\_exception\_translator}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{register\_exception\_translator()}{register\_exception\_translator()}}
{\footnotesize\ttfamily template$<$typename Exception\+Translator $>$ \\
void register\+\_\+exception\+\_\+translator (\begin{DoxyParamCaption}\item[{Exception\+Translator \&\&}]{translator }\end{DoxyParamCaption})}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{pybind11_8h_a0a77063d21919c13ddfeb8caf29eef59_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{pybind11_8h_a32d62802b102a8ac8362eeef769aaad4}\label{pybind11_8h_a32d62802b102a8ac8362eeef769aaad4}} 
\index{pybind11.h@{pybind11.h}!set\_operator\_new@{set\_operator\_new}}
\index{set\_operator\_new@{set\_operator\_new}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{set\_operator\_new()}{set\_operator\_new()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename $>$ \\
void set\+\_\+operator\+\_\+new (\begin{DoxyParamCaption}\item[{}]{... }\end{DoxyParamCaption})}

\mbox{\Hypertarget{pybind11_8h_ae55b858834fdd3c6adb5e8b9615b49b6}\label{pybind11_8h_ae55b858834fdd3c6adb5e8b9615b49b6}} 
\index{pybind11.h@{pybind11.h}!set\_operator\_new@{set\_operator\_new}}
\index{set\_operator\_new@{set\_operator\_new}!pybind11.h@{pybind11.h}}
\doxysubsubsection{\texorpdfstring{set\_operator\_new()}{set\_operator\_new()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename  = void\+\_\+t$<$decltype(static\+\_\+cast$<$void $\ast$($\ast$)(size\+\_\+t)$>$(\+T\+::operator new))$>$$>$ \\
void set\+\_\+operator\+\_\+new (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structtype__record}{type\+\_\+record}} $\ast$}]{r }\end{DoxyParamCaption})}



Set the pointer to operator new if it exists. The cast is needed because it can be overloaded. 

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=267pt]{pybind11_8h_ae55b858834fdd3c6adb5e8b9615b49b6_cgraph}
\end{center}
\end{figure}
